import fs from "fs";
import path from "path";

// IMPORTANT: ts-node will run this file so we can import your TS data files directly.
import { mockIcons } from "../data/mockIcons";
import { mockIconsDuo } from "../data/mockIconsDuo";

type IconData = {
  name: string;
  svgContent: string;
  // other fields ignored
};

const allIcons = [...(mockIcons as IconData[]), ...(mockIconsDuo as IconData[])];

function toPascalCase(name: string) {
  // remove invalid chars and convert to PascalCase
  return name
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .split(" ")
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join("");
}

function makeSafeFilename(name: string) {
  const s = name.replace(/[^a-zA-Z0-9]/g, "");
  return s || "Icon";
}

const outIconsDir = path.resolve(__dirname, "../src/lib/icons");
const outIndexFile = path.resolve(__dirname, "../src/lib/index.ts");

// wipe + recreate target folder
fs.rmSync(outIconsDir, { recursive: true, force: true });
fs.mkdirSync(outIconsDir, { recursive: true });

const exportedNames = new Set<string>();
const exportLines: string[] = [];

for (const icon of allIcons) {
  if (!icon || !icon.name || !icon.svgContent) continue;

  const rawName = toPascalCase(icon.name);
  // ensure unique
  let name = rawName;
  let i = 1;
  while (exportedNames.has(name)) {
    name = `${rawName}${i++}`;
  }
  exportedNames.add(name);

  const filename = `${makeSafeFilename(name)}.tsx`;
  const filePath = path.join(outIconsDir, filename);

  // Clean the svg string: remove xml header, remove width/height, remove xmlns (we'll set props)
  let svg = icon.svgContent
    .replace(/^\s*<\?xml[\s\S]*?\?>\s*/i, "")
    .replace(/<!DOCTYPE[\s\S]*?>\s*/i, "")
    .replace(/\s+xmlns(:\w+)?="[^"]*"/gi, "")
    .replace(/\s+width="[^"]*"/gi, "")
    .replace(/\s+height="[^"]*"/gi, "");

  // extract viewBox or default
  const vbMatch = svg.match(/viewBox="([^"]+)"/i);
  const viewBox = vbMatch ? vbMatch[1] : "0 0 24 24";

  // get inner content (everything between <svg ...> and </svg>)
  const inner = svg.replace(/^[\s\S]*?<svg[^>]*>/i, "").replace(/<\/svg>\s*$/i, "").trim();

  // convert attribute names to JSX-friendly names & replace hard hex colors to use `color` prop
  let jsxInner = inner
    .replace(/stroke-width="/gi, "strokeWidth=\"")
    .replace(/stroke-linecap="/gi, "strokeLinecap=\"")
    .replace(/stroke-linejoin="/gi, "strokeLinejoin=\"")
    .replace(/fill-rule="/gi, "fillRule=\"")
    .replace(/clip-rule="/gi, "clipRule=\"")
    .replace(/\bclass="/gi, "className=\"")
    // replace hex colors in stroke & fill to use color prop so icons are themeable
    .replace(/stroke="#[^"]*"/gi, "stroke={color}")
    .replace(/fill="#[^"]*"/gi, "fill={color}");

  // Build component string
  const componentSource = `import * as React from "react";

export interface IconProps extends React.SVGProps<SVGSVGElement> {
  size?: number;
  strokeWidth?: number;
  color?: string;
}

export const ${name}: React.FC<IconProps> = ({
  size = 24,
  strokeWidth = 1.5,
  color = "currentColor",
  ...props
}) => (
  <svg
    width={size}
    height={size}
    viewBox="${viewBox}"
    fill="none"
    stroke={color}
    strokeWidth={strokeWidth}
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    ${jsxInner}
  </svg>
);

export default ${name};
`;

  fs.writeFileSync(filePath, componentSource, "utf8");

  // add export line (relative to src/lib)
  const exportPath = `./icons/${path.basename(filename, ".tsx")}`;
  exportLines.push(`export { ${name} } from "${exportPath}";`);
}

const indexContent = `/* THIS FILE IS AUTO-GENERATED BY scripts/generate-icons.ts */
${exportLines.join("\n")}
`;

fs.writeFileSync(outIndexFile, indexContent, "utf8");
console.log("✅ Generated", exportedNames.size, "icon components to src/lib/icons");
console.log("✅ Generated src/lib/index.ts");
